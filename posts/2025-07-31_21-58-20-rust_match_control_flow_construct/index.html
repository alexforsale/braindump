<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>rust match | Braindump</title><meta name=keywords content="rust,programming"><meta name=description content="match Control flow construct
Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.
Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution."><meta name=author content="Kristian Alexander P"><link rel=canonical href=/braindump/posts/2025-07-31_21-58-20-rust_match_control_flow_construct/><link crossorigin=anonymous href=/braindump/assets/css/stylesheet.c5de734fbd88c3d21543485ffbcb1ccdda89a86a780cf987fa00199c41dbc947.css integrity="sha256-xd5zT72Iw9IVQ0hf+8sczdqJqGp4DPmH+gAZnEHbyUc=" rel="preload stylesheet" as=style><link rel=icon href=/braindump/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/braindump/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/braindump/favicon-32x32.png><link rel=apple-touch-icon href=/braindump/apple-touch-icon.png><link rel=mask-icon href=/braindump/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=/braindump/posts/2025-07-31_21-58-20-rust_match_control_flow_construct/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="rust match"><meta property="og:description" content="match Control flow construct
Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.
Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution."><meta property="og:type" content="article"><meta property="og:url" content="/braindump/posts/2025-07-31_21-58-20-rust_match_control_flow_construct/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="rust match"><meta name=twitter:description content="match Control flow construct
Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.
Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/braindump/posts/"},{"@type":"ListItem","position":2,"name":"rust match","item":"/braindump/posts/2025-07-31_21-58-20-rust_match_control_flow_construct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"rust match","name":"rust match","description":"match Control flow construct Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.\nThink of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.\n","keywords":["rust","programming"],"articleBody":"match Control flow construct Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.\nThink of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.\nenum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e 1, Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter =\u003e 25, } } Code Snippet 1: An enum and a match expression that has the variants of the enum as its patterns Let’s break down the match in the value_in_cents function. First we list the match keyword followed by an expression, which in this case is the value coin. This seems very similar to a conditional expression used with if, but there’s a big difference: with if, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of coin in this example is the Coin enum that we defined on the first line.\nNext are the match arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value Coin::Penny and then the =\u003e operator that separates the pattern and the code to run. The code in this case is just the value 1. Each arm is separated from the next with a comma.\nWhen the match expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need.\nThe code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression.\nfn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e { println!(\"Lucky penny!\"); 1 } Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter =\u003e 25, } } ","wordCount":"427","inLanguage":"en","datePublished":"2025-07-31T00:00:00Z","dateModified":"2025-07-31T00:00:00Z","author":[{"@type":"Person","name":"Kristian Alexander P"}],"mainEntityOfPage":{"@type":"WebPage","@id":"/braindump/posts/2025-07-31_21-58-20-rust_match_control_flow_construct/"},"publisher":{"@type":"Organization","name":"Braindump","logo":{"@type":"ImageObject","url":"/braindump/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=/braindump/ accesskey=h title="Braindump (Alt + H)">Braindump</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/braindump/ title=Braindump><span>Braindump</span></a></li><li><a href=/braindump/categories/ title=categories><span>categories</span></a></li><li><a href=/braindump/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=/braindump/>Home</a>&nbsp;»&nbsp;<a href=/braindump/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">rust match</h1><div class=post-meta><span title='2025-07-31 00:00:00 +0000 UTC'>July 31, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Kristian Alexander P</div></header><div class=post-content><h2 id=match-control-flow-construct><code>match</code> Control flow construct<a hidden class=anchor aria-hidden=true href=#match-control-flow-construct>#</a></h2><p><a href=/braindump/posts/2025-07-29_00-38-11-rust/>Rust</a> has an extremely powerful control flow construct called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things.</p><p>Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a <code>match</code>, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Coin</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Penny</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Nickel</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Dime</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Quarter</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>value_in_cents</span><span class=p>(</span><span class=n>coin</span>: <span class=nc>Coin</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u8</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>coin</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Penny</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Nickel</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Dime</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>10</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Quarter</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>25</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=src-block-caption><span class=src-block-number>Code Snippet 1:</span>
An <code>enum</code> and a <code>match</code> expression that has the variants of the enum as its patterns</div><p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional expression used with <code>if</code>, but there’s a big difference: with <code>if</code>, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> <a href=/braindump/posts/2025-07-31_20-06-17-rust_enums/>enum</a> that we defined on the first line.</p><p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=></code> operator that separates the pattern and the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next with a comma.</p><p>When the <code>match</code> expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need.</p><p>The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire <code>match</code> expression.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>value_in_cents</span><span class=p>(</span><span class=n>coin</span>: <span class=nc>Coin</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u8</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>coin</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Penny</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Lucky penny!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Nickel</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Dime</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>10</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Coin</span>::<span class=n>Quarter</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>25</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=/braindump/tags/rust/>Rust</a></li><li><a href=/braindump/tags/programming/>Programming</a></li></ul><nav class=paginav><a class=prev href=/braindump/posts/2025-07-31_19-49-54-rust_functions/><span class=title>« Prev</span><br><span>Rust Functions</span>
</a><a class=next href=/braindump/posts/2025-07-31_20-04-32-rust_ownership/><span class=title>Next »</span><br><span>Rust Ownership</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=/braindump/>Braindump</a></span>
<span><a href=https://github.com/alexforsale/braindump/ rel="noopener noreferrer" target=_blank>source</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>