<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>rust data types | Braindump</title><meta name=keywords content="rust"><meta name=description content="Data types forrust.
Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data.
Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.
Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust."><meta name=author content="Kristian Alexander P"><link rel=canonical href=/braindump/posts/2025-07-29_00-36-29-rust_data_types/><link crossorigin=anonymous href=/braindump/assets/css/stylesheet.c5de734fbd88c3d21543485ffbcb1ccdda89a86a780cf987fa00199c41dbc947.css integrity="sha256-xd5zT72Iw9IVQ0hf+8sczdqJqGp4DPmH+gAZnEHbyUc=" rel="preload stylesheet" as=style><link rel=icon href=/braindump/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/braindump/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/braindump/favicon-32x32.png><link rel=apple-touch-icon href=/braindump/apple-touch-icon.png><link rel=mask-icon href=/braindump/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=/braindump/posts/2025-07-29_00-36-29-rust_data_types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="rust data types"><meta property="og:description" content="Data types forrust.
Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data.
Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.
Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust."><meta property="og:type" content="article"><meta property="og:url" content="/braindump/posts/2025-07-29_00-36-29-rust_data_types/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-29T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="rust data types"><meta name=twitter:description content="Data types forrust.
Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data.
Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.
Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/braindump/posts/"},{"@type":"ListItem","position":2,"name":"rust data types","item":"/braindump/posts/2025-07-29_00-36-29-rust_data_types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"rust data types","name":"rust data types","description":"Data types forrust. Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data.\nKeep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.\nScalar Types A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust.\n","keywords":["rust"],"articleBody":"Data types forrust. Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data.\nKeep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time.\nScalar Types A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust.\nIntegers length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 architecture-dependent isize usize The isize and usize types depend on the architecture of the computer your program is running on: 64 bits if youâ€™re on a 64-bit architecture and 32 bits if youâ€™re on a 32-bit architecture.\nFloating Points Rust also has two primitive types for floating-point numbers, which are numbers with decimal points. Rustâ€™s floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively.\nThe default type is f64 because on modern CPUs, itâ€™s roughly the same speed as f32 but is capable of more precision. All floating-point types are signed.\nNumeric operation Rust supports the basic mathematical operations youâ€™d expect for all the number types: addition, subtraction, multiplication, division, and remainder. Integer division truncates toward zero to the nearest integer.\nfn main() { // addition let sum = 5 + 10; println!(\"sum is: {}\", sum); // subtraction let difference = 95.5 - 4.3; println!(\"difference is: {}\", difference); // multiplication let product = 4 * 30; println!(\"product is: {}\", product); // division let quotient = 56.7 / 32.2; println!(\"quotient is: {}\", quotient); let truncated = -5 / 3; // Results in -1 println!(\"truncated is: {}\", truncated); // remainder let remainder = 43 % 5; println!(\"remainder is: {}\", remainder); } sum is: 15 difference is: 91.2 product is: 120 quotient is: 1.7608695652173911 truncated is: -1 remainder is: 3 Boolean Type As in most other programming languages, a Boolean type in Rust has two possible values: true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool.\nfn main() { let t = true; let f: bool = false; // with explicit type annotation println!(\"f is {}\", f) } f is false Character Type Rustâ€™s char type is the languageâ€™s most primitive alphabetic type. Here are some examples of declaring char values:\nfn main() { let c = 'z'; let z: char = 'â„¤'; // with explicit type annotation let heart_eyed_cat = 'ðŸ˜»'; println!(\"c is {}, z is {}, and heart_eyed_cat is {}\", c, z, heart_eyed_cat); } c is z, z is â„¤, and heart_eyed_cat is ðŸ˜» Note that we specify char literals with single quotes, as opposed to string literals, which use double quotes.\nCompound Types Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.\nTuple Type A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.\nWe create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple donâ€™t have to be the same.\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } The variable tup binds to the entire tuple because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {y}\"); } The value of y is: 6.4 This program first creates a tuple and binds it to the variable tup. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.\nWe can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } This program creates the tuple x and then accesses each element of the tuple using their respective indices. As with most programming languages, the first index in a tuple is 0.\nThe tuple without any values has a special name, unit. This value and its corresponding type are both written () and represent an empty value or an empty return type. Expressions implicitly return the unit value if they donâ€™t return any other value.\nAdditionally, we can modify individual elements of a mutable tuple. For example:\nfn main() { let mut x: (i32, i32) = (1, 2); x.0 = 0; x.1 += 5; println!(\"x is {:?}\", x) } x is (0, 7) Array Type Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length.\nWe write the values in an array as a comma-separated list inside square brackets:\nfn main() { let a = [1, 2, 3, 4, 5]; } Arrays are more useful when you know the number of elements will not need to change. For example, if you were using the names of the month in a program, you would probably use an array rather than a vector because you know it will always contain 12 elements:\nlet months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]; You write an arrayâ€™s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:\nlet a: [i32; 5] = [1, 2, 3, 4, 5]; Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.\nYou can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:\nlet a = [3; 5]; println!(\"{:?}\", a); [3, 3, 3, 3, 3] Accessing array elements An array is a single chunk of memory of a known, fixed size that can be allocated on the stack. You can access elements of an array using indexing, like this:\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; println!(\"a is: {:?}, first is {}, second is {}\", a, first, second) } a is: [1, 2, 3, 4, 5], first is 1, second is 2 Backlinks rust variables ","wordCount":"1190","inLanguage":"en","datePublished":"2025-07-29T00:00:00Z","dateModified":"2025-07-29T00:00:00Z","author":[{"@type":"Person","name":"Kristian Alexander P"}],"mainEntityOfPage":{"@type":"WebPage","@id":"/braindump/posts/2025-07-29_00-36-29-rust_data_types/"},"publisher":{"@type":"Organization","name":"Braindump","logo":{"@type":"ImageObject","url":"/braindump/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=/braindump/ accesskey=h title="Braindump (Alt + H)">Braindump</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/braindump/categories/ title=categories><span>categories</span></a></li><li><a href=/braindump/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=/braindump/>Home</a>&nbsp;Â»&nbsp;<a href=/braindump/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">rust data types</h1><div class=post-meta><span title='2025-07-29 00:00:00 +0000 UTC'>July 29, 2025</span>&nbsp;Â·&nbsp;6 min&nbsp;Â·&nbsp;Kristian Alexander P</div></header><div class=post-content><p>Data types for<a href=/braindump/posts/2025-07-29_00-38-11-rust/>rust</a>.
Every value in Rust is of a certain <em>data type</em>, which tells Rust what kind of data is being specified so it knows how to work with that data.</p><p>Keep in mind that Rust is a <em>statically typed</em> language, which means that it must know the types of all variables at compile time.</p><h2 id=scalar-types>Scalar Types<a hidden class=anchor aria-hidden=true href=#scalar-types>#</a></h2><p>A <em>scalar type</em> represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Letâ€™s jump into how they work in Rust.</p><h3 id=integers>Integers<a hidden class=anchor aria-hidden=true href=#integers>#</a></h3><table><thead><tr><th>length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>architecture-dependent</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>The <code>isize</code> and <code>usize</code> types depend on the architecture of the computer your program is running on: 64 bits if youâ€™re on a 64-bit architecture and 32 bits if youâ€™re on a 32-bit architecture.</p><h3 id=floating-points>Floating Points<a hidden class=anchor aria-hidden=true href=#floating-points>#</a></h3><p>Rust also has two primitive types for <em>floating-point</em> numbers, which are numbers with decimal points. Rustâ€™s floating-point types are <code>f32</code> and <code>f64</code>, which are 32 bits and 64 bits in size, respectively.</p><p>The default type is <code>f64</code> because on modern CPUs, itâ€™s roughly the same speed as <code>f32</code> but is capable of more precision. All floating-point types are signed.</p><h4 id=numeric-operation>Numeric operation<a hidden class=anchor aria-hidden=true href=#numeric-operation>#</a></h4><p>Rust supports the basic mathematical operations youâ€™d expect for all the number types: addition, subtraction, multiplication, division, and remainder. Integer division truncates toward zero to the nearest integer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// addition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;sum is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// subtraction
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>difference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>95.5</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mf>4.3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;difference is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>difference</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// multiplication
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>30</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;product is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>product</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// division
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>quotient</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>56.7</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>32.2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;quotient is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>quotient</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>truncated</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=mi>5</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w> </span><span class=c1>// Results in -1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;truncated is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>truncated</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// remainder
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>43</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;remainder is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>remainder</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>sum is: 15
</span></span><span class=line><span class=cl>difference is: 91.2
</span></span><span class=line><span class=cl>product is: 120
</span></span><span class=line><span class=cl>quotient is: 1.7608695652173911
</span></span><span class=line><span class=cl>truncated is: -1
</span></span><span class=line><span class=cl>remainder is: 3
</span></span></code></pre></div><h3 id=boolean-type>Boolean Type<a hidden class=anchor aria-hidden=true href=#boolean-type>#</a></h3><p>As in most other programming languages, a Boolean type in Rust has two possible values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in Rust is specified using <code>bool</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>f</span>: <span class=kt>bool</span> <span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w> </span><span class=c1>// with explicit type annotation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;f is </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>f</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>f is false
</span></span></code></pre></div><h3 id=character-type>Character Type<a hidden class=anchor aria-hidden=true href=#character-type>#</a></h3><p>Rustâ€™s <code>char</code> type is the languageâ€™s most primitive alphabetic type. Here are some examples of declaring <code>char</code> values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sc>&#39;z&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>z</span>: <span class=kt>char</span> <span class=o>=</span><span class=w> </span><span class=sc>&#39;â„¤&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>// with explicit type annotation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>heart_eyed_cat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sc>&#39;ðŸ˜»&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;c is </span><span class=si>{}</span><span class=s>, z is </span><span class=si>{}</span><span class=s>, and heart_eyed_cat is </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=p>,</span><span class=w> </span><span class=n>heart_eyed_cat</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>c is z, z is â„¤, and heart_eyed_cat is ðŸ˜»
</span></span></code></pre></div><p>Note that we specify <code>char</code> literals with single quotes, as opposed to string literals, which use double quotes.</p><h2 id=compound-types>Compound Types<a hidden class=anchor aria-hidden=true href=#compound-types>#</a></h2><p><em>Compound types</em> can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.</p><h3 id=tuple-type>Tuple Type<a hidden class=anchor aria-hidden=true href=#tuple-type>#</a></h3><p>A <code>tuple</code> is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p><p>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple donâ€™t have to be the same.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tup</span>: <span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>500</span><span class=p>,</span><span class=w> </span><span class=mf>6.4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>500</span><span class=p>,</span><span class=w> </span><span class=mf>6.4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=n>z</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tup</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The value of y is: </span><span class=si>{y}</span><span class=s>&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>The value of y is: 6.4
</span></span></code></pre></div><p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then uses a pattern with let to take <code>tup</code> and turn it into three separate variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em> because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.</p><p>We can also access a tuple element directly by using a period (<code>.</code>) followed by the index of the value we want to access. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>500</span><span class=p>,</span><span class=w> </span><span class=mf>6.4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>five_hundred</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>six_point_four</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>one</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This program creates the tuple <code>x</code> and then accesses each element of the tuple using their respective indices. As with most programming languages, the first index in a tuple is 0.</p><p>The tuple without any values has a special name, unit. This value and its corresponding type are both written <code>()</code> and represent an empty value or an empty return type. Expressions implicitly return the unit value if they donâ€™t return any other value.</p><p>Additionally, we can modify individual elements of a mutable tuple. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>x</span>: <span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span><span class=p>.</span><span class=mi>1</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;x is </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>x is (0, 7)
</span></span></code></pre></div><h3 id=array-type>Array Type<a hidden class=anchor aria-hidden=true href=#array-type>#</a></h3><p>Another way to have a collection of multiple values is with an <em>array</em>. Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length.</p><p>We write the values in an array as a comma-separated list inside square brackets:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Arrays are more useful when you know the number of elements will not need to change. For example, if you were using the names of the month in a program, you would probably use an array rather than a vector because you know it will always contain 12 elements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>months</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=s>&#34;January&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;February&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;March&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;April&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;May&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;June&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;July&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=s>&#34;August&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;September&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;October&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;November&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;December&#34;</span><span class=p>];</span><span class=w>
</span></span></span></code></pre></div><p>You write an arrayâ€™s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span>: <span class=p>[</span><span class=kt>i32</span><span class=p>;</span><span class=w> </span><span class=mi>5</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w>
</span></span></span></code></pre></div><p>Here, <code>i32</code> is the type of each element. After the semicolon, the number <code>5</code> indicates the array contains five elements.</p><p>You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>3</span><span class=p>;</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[3, 3, 3, 3, 3]
</span></span></code></pre></div><h4 id=accessing-array-elements>Accessing array elements<a hidden class=anchor aria-hidden=true href=#accessing-array-elements>#</a></h4><p>An array is a single chunk of memory of a known, fixed size that can be allocated on the stack. You can access elements of an array using indexing, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>second</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;a is: </span><span class=si>{:?}</span><span class=s>, first is </span><span class=si>{}</span><span class=s>, second is </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>first</span><span class=p>,</span><span class=w> </span><span class=n>second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>a is: [1, 2, 3, 4, 5], first is 1, second is 2
</span></span></code></pre></div><h2 id=backlinks>Backlinks<a hidden class=anchor aria-hidden=true href=#backlinks>#</a></h2><ul><li><a href=/braindump/posts/2025-07-31_19-14-21-rust_variables/>rust variables</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/braindump/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=/braindump/posts/2025-07-29_00-38-11-rust/><span class=title>Â« Prev</span><br><span>rust</span>
</a><a class=next href=/braindump/posts/2025-07-29_05-52-54-rust_struct/><span class=title>Next Â»</span><br><span>rust struct</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=/braindump/>Braindump</a></span>
<span><a href=https://github.com/alexforsale/braindump/ rel="noopener noreferrer" target=_blank>source</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>